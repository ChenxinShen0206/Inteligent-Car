 /**********************************************************************************************************************
 * \file Cpu2_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "XinDongLib/Interrupts.h"
#include "XinDongLib/Intercore.h"
#include "XinDongLib/Bluetooth.h"
#include "XinDongLib/Display.h"
#include "XinDongLib/Encoder.h"
#include "XinDongLib/IMU.h"
#include "XinDongLib/IO.h"
#include "XinDongLib/Movements.h"
#include "XinDongLib/Serial.h"
#include "XinDongLib/Ultrasonic.h"
#include "XinDongLib/Time.h"
#include "XinDongLib/ADC.h"
#include "XinDongLib/PID.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

typedef struct {
	uint8 buffer[2];
	uint8 len, id;	// id=  1:set led 4 state, 2:set servo angle, 3:draw rectangle on OLED, !!! 0x10:remote package !!!
	uint8 state;	// 0:ready, 1:wait for id, 2:wait for length, 3:receiving, 4:wait for tail 1, 5:wait for tail 2, 6:length error
} Decoder;

// structure to record the remote state
// 用来记录遥控器状态的结构体
struct {
	float steering;
	float power;
	uint8 buttonA, buttonB, buttonC, buttonD;
} remote = { 0 };

// decoder on BLE serial port
// 蓝牙串口的解包解码器
Decoder decoder_ble = { .state = 0 };

uint8 receive_buffer[256];

void core2_main(void) {
	IfxCpu_enableInterrupts();
	/* !!WATCHDOG2 IS DISABLED HERE!!
	 * Enable the watchdog and service it periodically if it is required
	 */
	IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());

	/* Wait for CPU sync event */
	IfxCpu_emitEvent(&g_cpuSyncEvent);
	IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

	// wait for signal to begin initialization
	while (Intercore_InitAllowed() == 0)
		;

	// initialize any module needed
	Serial_Init();
	Bluetooth_Init();
	ADC_Init();
	Ultrasonic_Init();
	OLED_Init();
	MPU6050_Init();
	Encoder_Init();
	Servo_Init();
	Motor_Init();

	// wait for other cores to finish initialization
	Intercore_CPU2_Ready();
	while (Intercore_ReadyToGo() == 0)
		;

	// set servo center
	// 设置舵机中心点
	Servo_SetCenter(0.205);  /* 0.5pt */
	Servo_Set(0);

	// set motor polarity
	// 设置电机极性
 	Motor_SetPolarity(1);  /* 0.5pt */

	// main loop
	while (1) {
		// some code to indicate that the core is not dead
		IO_LED_Toggle(3);
		Time_Delay_us(100000);
		// update OLED display
		OLED_Update();
	}
}

// throttle curve mapping
// 油门曲线映射
/*
 * output
 * 	^
 * 	|                                   *
 * 	|                                  *
 * 	|                                 *
 * 	|                                *
 * 	|                               *
 * 	|                             * :
 * 	|                          *    :
 * 	|                       *       :
 * 	|                    *          :
 * 	|                *   :          :
 * 	|           *        :          :
 * 	|      *		     :          :
 * 	| *				     :          :
 * 	---------------------------------------> input
 * 	0%					50%			80%
 */
// input:[-1,+1], output:[-1:+1]
// 输入：[-1,+1]，输出：[-1:+1] （区间）
float throttle_remap(float value) {
	float absvalue, sign;
	// get absolute value and sign
	// 获取绝对值与符号
	absvalue = value < 0 ? value * -1.0 : value ; // calculate absvalue    /* 1pt */
	sign = value < 0 ? -1.0 : 1.0;

	// if absvalue is less / no more than the first input threshold
	// 若绝对值absvalue小于/不大于第一个输入阈值
	if (absvalue < 0.5) {
		// return a linear mapping
		// 返回一个线性映射
		return value * 0.5;
	}
	// return now to limit output amplitude to 0.25 max
	// 在这里返回以保证输出幅度最大为0.25
	//return ...;  /* 1pt */
	// lines after this return is never run, but keep them here in case they are needed in the future
	// 这个return之后的语句不会被运行，但是留着吧，万一将来用到了呢

	// if absvalue is larger / no smaller than the first threshold and less / no larger than the second input threshold
	// 若绝对值大于/不小于第一个阈值且小于/不大于第二个阈值
	if (absvalue < 0.8) {
		// then calculate its output with a different slope in the region larger than the first threshold and return it
		// 那么用一个新的斜率去计算超出第一个阈值的部分并将其返回
		// tips: calculate offset and coefficient according to max output below previous threshold and offset in output of next threshold (make it continuous)
		// 提示：根据上一个阈值之内的最大输出值与下一个阈值计算输出时加的常数来确定计算当前输出所需的常数与系数（使之连续）
 		return sign * (0.25 + (absvalue - 0.5));  /* 1pt */
	}

	// if absvalue is larger / no smaller than the second threshold and less / no larger than the last input threshold
	// 若绝对值大于/不小于第二个阈值且小于/不大于最后一个阈值
	if (absvalue <= 1) {
		// then calculate its output with a different slope in the region larger than the second threshold and return it
		// 那么用一个新的斜率去计算超出第二个阈值的部分并将其返回
		return sign * (0.55 + (absvalue - 0.8) * 2);
	}

	// if absvalue is larger than the last threshold, which should not happen
	// 当绝对值超过最后的阈值（不应该超过最后的阈值 1.0）
	return 0;	// just return zero
}

// execute command from multi-byte package
void execute(Decoder *decoderptr) {
	float angle;
	uint16 tempu16;
	switch (decoderptr->id) {
	case 1:  // set led 4 state
		if (receive_buffer[0] == 0) {
			IO_LED_Off(4);
		} else {
			IO_LED_On(4);
		}
		break;
	case 2:  // set servo angle:-100~100
		angle = (sint8) receive_buffer[0];
		Servo_Set(angle);
		break;
	case 3:  // draw rectangle on OLED
		OLED_DrawRectangle(receive_buffer[0], receive_buffer[1], receive_buffer[2], receive_buffer[3], receive_buffer[4]);
		break;
	case 0x10:  // data from remote
		// record data
		tempu16 = receive_buffer[1];
		tempu16 <<= 8;
		tempu16 |= receive_buffer[0];
		remote.power = - (sint16) tempu16;  // stupid APP author forward is negative
		remote.steering = - (sint8) receive_buffer[2];  // -:remote left, +:remote right
		remote.buttonA = receive_buffer[3] & (1 << 7);
		remote.buttonB = receive_buffer[3] & (1 << 6);
		remote.buttonC = receive_buffer[3] & (1 << 5);
		remote.buttonD = receive_buffer[3] & (1 << 4);

		// update outputs: normalize remote.power and remote.steering according to their range from remote and the input range of functions
		// 更新输出：根据remote.power和remote.steering（油门/速度 与 转向角度）从遥控器发送来的数据的范围和函数输入参数范围对它们进行归一化
		// tips: range of sint16 and sint8
		Motor_Set(throttle_remap(remote.power/110000+0.15));  /* 1pt */
		Servo_Set(remote.steering/90);  /* 1pt */
		/*OLED_ShowString(0, 0, "Motor:", OLED_8X16);
		        OLED_ShowFloatNum(64, 0, remote.power/60000,4,2 ,OLED_8X16);
		        OLED_ShowString(0, 16, "Servo:", OLED_8X16);
		        OLED_ShowFloatNum(64, 16, remote.steering/150, 4,2,  OLED_8X16);
		        OLED_Update();*/
		break;
	default:  // unused id
		break;
	}
}

// decode function for multi-byte
uint8 decode(Decoder *decoderptr) {
	switch (decoderptr->state) {
	case 0:  // ready state
		if (decoderptr->buffer[1] == 0xAA && decoderptr->buffer[0] == 0x55) {
			decoderptr->state = 1;
		}
		return 0;
	case 1:
		decoderptr->id = decoderptr->buffer[0];
		decoderptr->state = 2;
		return 0;
	case 2:
		decoderptr->len = decoderptr->buffer[0];
		decoderptr->state = 3;
		return decoderptr->len;
	case 3:
		decoderptr->state = 4;
		return 0;
	case 4:
		if (decoderptr->buffer[0] == 0x55) {
			decoderptr->state = 5;
		} else {
			decoderptr->state = 6;
		}
		return 0;
	case 5:
		if (decoderptr->buffer[0] == 0xAA) {
			decoderptr->state = 0;
			execute(decoderptr);
		} else {
			decoderptr->state = 6;
		}
		return 0;
	default:  // error and unexpected state
		decoderptr->state = 0;	// just reset to ready state
		return 0;
	}
}

/* list out all ISR for CPU2 */

void Periodic_1s_ISR(void) {
	;
}

void Periodic_100ms_ISR(void) {
	;
}

void Periodic_10ms_ISR(void) {
	;
}

void Periodic_PID_ISR(void) {
	;
}

void SWINT_User0_ISR(void) {
	;
}

void SWINT_User1_ISR(void) {
	;
}

void SWINT_User2_ISR(void) {
	;
}

void SWINT_User3_ISR(void) {
	;
}

void Serial_Received(uint8 *dataptr, uint32 length, uint8 tag) {
	switch (tag) {
	case 1:

		break;
	default:
		;
	}
}

void Bluetooth_Received(uint8 *dataptr, uint32 length, uint8 tag) {
	uint8 receive_length = 0;
	if (tag == 0) {
		decoder_ble.buffer[1] = decoder_ble.buffer[0];
		decoder_ble.buffer[0] = *dataptr;
		receive_length = decode(&decoder_ble);
		if (receive_length != 0) {
			Bluetooth_Receive(receive_buffer, decoder_ble.len, decoder_ble.id);
		}
	} else {
		if (tag == decoder_ble.id) {
			decode(&decoder_ble);
		}
	}
}

void Reed_Triggered(void) {
	;
}
