/**********************************************************************************************************************
 * \file Cpu2_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "XinDongLib/Interrupts.h"
#include "XinDongLib/Intercore.h"
#include "XinDongLib/Bluetooth.h"
#include "XinDongLib/Display.h"
#include "XinDongLib/Encoder.h"
#include "XinDongLib/IMU.h"
#include "XinDongLib/IO.h"
#include "XinDongLib/Movements.h"
#include "XinDongLib/Serial.h"
#include "XinDongLib/Ultrasonic.h"
#include "XinDongLib/Time.h"
#include "XinDongLib/ADC.h"
#include "XinDongLib/Camera.h"
#include "XinDongLib/PID.h"
#include <stdint.h>

#define SPEED_MA_N 4   /* 8*10ms=80ms */

static int32_t sp_buf[SPEED_MA_N] = {0};
static uint8_t sp_idx = 0;
static int32_t sp_sum = 0;
PID_Handler g_speed_pid;

sint32 enc_num, speed;
float pid_out;

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void) {
    IfxCpu_enableInterrupts();
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    // wait for signal to begin initialization
    while (Intercore_InitAllowed() == 0)
        ;

	// initialize any module needed
	Serial_Init();
	Bluetooth_Init();
	ADC_Init();
	Ultrasonic_Init();
	OLED_Init();
	MPU6050_Init();
	Encoder_Init();
	Servo_Init();
	Motor_Init();
    PID_Init(&g_speed_pid);
    PID_SetParams(&g_speed_pid,  2.442e-6, 6.923e-4, 2.345e-4);  /* 参数示例，按车实调 */

    // wait for other cores to finish initialization
    Intercore_CPU2_Ready();
    while (Intercore_ReadyToGo() == 0)
        ;

    // main loop
    while (1) {
        // some code to indicate that the core is not dead
        IO_LED_Toggle(3);
        Time_Delay_us(100000);
//        CV_Result_t result = CV_ProcessImage();
//        float angle_error = result.error;
//        Servo_Set(angle_error);
    }
}

/* list out all ISR for CPU2 */

void Periodic_1s_ISR(void) {
    ;
}

sint32 encoder_value_last = 0;

void Periodic_100ms_ISR(void) {
    ;
}

float average_speed = 0;  // 用于存放平滑后的速度（调试/显示用）

void Periodic_10ms_ISR(void) {   // 该函数每 10ms 进入一次，相当于速度环的采样周期 = 100Hz

       // 1) 计算当前 10ms 内编码器的增量
       // Encoder_GetValue() 返回编码器累计计数
       // delta = 当前累计计数 - 上一次累计计数
//       sint32 delta = Encoder_GetValue() - encoder_value_last;
//       encoder_value_last = Encoder_GetValue();  // 更新“上一次计数”

       // 2) 滑动平均滤波：用于降低编码器抖动和噪声
//       sp_sum -= sp_buf[sp_idx];     // 去掉最旧的一个值
//       sp_buf[sp_idx] = delta;       // 把最新的增量放入缓冲区
//       sp_sum += delta;              // 加上最新的值
//       sp_idx++;                     // 环形索引后移
//       if (sp_idx >= SPEED_MA_N)     // 如果超过窗口长度，回到开头
//           sp_idx = 0;

       // 3) 计算滑动平均后的速度
       // speed_f = 最近 N 次采样的平均增量
       // 单位：脉冲数/10ms，如果要转化成脉冲/秒，需要乘以 100
//       float speed_f = (float)sp_sum / (float)SPEED_MA_N;

       // 4) 用平滑后的速度做 PID 计算
       // 目标速度 = 40.0f（单位要和 speed_f 一致，这里是“脉冲/10ms”）
       // speed_f = 当前反馈速度
       // pid_out = PID 输出，用来控制电机 PWM
//       pid_out = PID_Output(&g_speed_pid, 0.15f, speed_f);

       // 5) 对 PID 输出做限幅，避免输出过大损坏电机或驱动
       // 输出范围限制在 [-0.4, +0.4]（即占空比最大约 40%）
//       pid_out = pid_out > 0.4f ? 0.4f : (pid_out < -0.4f ? -0.4f : pid_out);

       // 6) 给电机输出控制量
       // 注意这里取了负号：Motor_Set(-pid_out)
       // 这是为了匹配编码器方向，如果发现电机跑反，改成 Motor_Set(pid_out)
//       Motor_Set(-0.14);

       // 7) 保存数据用于调试/显示
//       enc_num = encoder_value_last;        // 编码器累计值（总脉冲数）
//       speed   = (sint32)speed_f;           // 平滑后的速度（整数化，用于显示/串口输出）


}



void Periodic_PID_ISR(void) {

    ;

}

void SWINT_User0_ISR(void) {
    ;
}

void SWINT_User1_ISR(void) {
    ;
}

void SWINT_User2_ISR(void) {
    ;
}

void SWINT_User3_ISR(void) {
    ;
}

void Serial_Received(uint8 *dataptr, uint32 length, uint8 tag) {
    switch (tag) {
    case 1:

        break;
    default:
        ;
    }
}

void Bluetooth_Received(uint8 *dataptr, uint32 length, uint8 tag) {
    switch (tag) {
    case 1:

        break;
    default:
        ;
    }
}

void Reed_Triggered(void) {
	;
}
